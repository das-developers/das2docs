#!/usr/bin/env python3

import sys

from lxml import etree
try:
    from StringIO import StringIO # Python 2
except ImportError:
    from io import StringIO       # Python 3
	 
g_sStrSchema = './schema/das2_stream-2.3.xsd'
g_sPktSchema = './schema/das2_packet-2.3.xsd'
g_sCmtSchema = './schema/das2_comment-2.3.xsd'

# ########################################################################### #
def getHdr(fIn, nOffset):
	"""Returns (sPktId, sDoc, nOffset)"""

	x4 = fIn.read(4)
	nOffset += 4

	if (nOffset == 0) and (x4 != b'[00]'):
		print("File does not start with '[00]' does not appear to be a das2 stream")
		return 1
	
	try:
		sPktId = x4[1:3].decode("utf-8")
		if sPktId == "00": sPktType = "stream"
		elif sPktId in ('xx','XX'): sPktType = "comment"
		else: sPktType = "packet"
			
	except UnicodeDecodeError:
		print("Packet ID not readable as UTF-8 text at byte offset %d"%(nOffset - 4))
		return (None, None, nOffset)
	
	x6 = fIn.read(6)
	nOffset += 6
	if len(x6) != 6:
		print("Could not get header packet length at byte offset %d"%(nOffest - 6 ))
		return (sPktId, None, nOffset)
			
	nLen = 0
	try:
		nLen = int(x6.decode('utf-8'), 10)
	except ValueError:
		print("Could not convert header packet length string to an integer at byte offset %d"%(
		       nOffset - 6))
		return (sPktId, None, nOffset)
		
	if nLen < 8:
		print("Packet length (%d) is to short to be a legal stream "%nLen +\
		      "or packet descriptor at byte offset %d"%nOffset)
		return (sPktId, None, nOffset)
	
	print("Reading %d byte %s header packet"%(nLen, sPktType))
	xDoc = fIn.read(nLen)
	sDoc = None
	try:
		sDoc = xDoc.decode("utf-8")
		#print(sDoc)
	except UnicodeDecodeError:
		print("%s header starting at byte %d is not valid UTF-8 text"(sPktType, nOffset))
		return (sPktId, None, nOffset)
	
	return (sPktId, sDoc, nOffset)


# ########################################################################### #
def main(lArgs):
		
	fStrSchema = open(g_sStrSchema)
	fPktSchema = open(g_sPktSchema)
	fCmtSchema = open(g_sCmtSchema)

	str_schema_doc = etree.parse(fStrSchema)
	str_schema = etree.XMLSchema(str_schema_doc)
	
	pkt_schema_doc = etree.parse(fPktSchema)
	pkt_schema = etree.XMLSchema(pkt_schema_doc)
	
	cmt_schema_doc = etree.parse(fCmtSchema)
	cmt_schema = etree.XMLSchema(cmt_schema_doc)
	
	fIn = open(lArgs[1], 'rb')
	
	sPktId, sStrDoc, nOffset = getHdr(fIn, 0)
	if sStrDoc == None: return 7
	fPkt = StringIO(sStrDoc)
	str_doc = etree.parse(fPkt)
	
	bGood = False
	try:
		str_schema.assertValid(str_doc)
		bGood = True
	except etree.DocumentInvalid as e:
		print("In <stream> header: %s" %str(e))
		return 5
	
	if bGood:
		print("%s validated against schema %s."%(lArgs[0], g_sStrSchema))
		
	else:
		print("%s failed to validate against schema %s."%(lArgs[0], g_sSchema))
		return 7
		
		
	sPktId, sPktDoc, nOffset = getHdr(fIn, nOffset)
	if sPktDoc == None: return 13
	
	fPkt = StringIO(sPktDoc)
	pkt_doc = etree.parse(fPkt)
	
	bGood = False
	try:
		pkt_schema.assertValid(pkt_doc)
		bGood = True
	except etree.DocumentInvalid as e:
		print("In <packet> [%s] header: %s" %(sPktId, str(e)))
		return 5
	
	if bGood:
		print("%s validated against schema %s."%(lArgs[0], g_sPktSchema))
		
	else:
		print("%s failed to validate against schema %s."%(lArgs[0], g_sSchema))
		return 7
	
if __name__ == "__main__":
	sys.exit(main(sys.argv))
